SELECT * FROM vehicle;

SELECT * FROM car_brand;

DROP TABLE vehicle;

DROP TABLE car_brand;


CREATE TABLE car_brand (
                           id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY ,
                           brand_name varchar(50) NOT NULL,
                           car_type varchar(50) NOT NULL,
                           fuel_tank_volume double precision NOT NULL,
                           carrying_capacity double precision NOT NULL,
                           number_of_seats int NOT NULL,
                           max_speed int NOT NULL
);

CREATE TABLE vehicle (
                         id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY ,
                         number_vehicle varchar(50) NOT NULL,
                         price double precision NOT NULL,
                         year_of_manufacture int NOT NULL CHECK (year_of_manufacture >= 2003 AND year_of_manufacture <= 2023),
                         mileage int NOT NULL,
                         equipment_type varchar(50),
                         car_brand_id int REFERENCES car_brand(id)
);

INSERT INTO car_brand (brand_name, car_type, fuel_tank_volume, carrying_capacity, number_of_seats, max_speed)
VALUES
    ('MERCEDES', 'SEDAN', 50.1, 1000.0, 4, 210),
    ('TOYOTA', 'TRUCK', 70.1, 2000.0, 2, 180),
    ('BMW', 'BUS', 80.0, 3000.0, 30, 160),
    ('FORD', 'PICKUP', 90.0, 1800.0, 5, 190),
    ('AUDI', 'SPORTS', 60.0, 1200.0, 2, 250);


-- Заполним таблицу vehicle данными
INSERT INTO vehicle (number_vehicle, price, year_of_manufacture, mileage, equipment_type, car_brand_id)
VALUES
    -- для бренда MERCEDES
    ('M001AB', 2200.0, 2012, 6000, 'BASIC', 1),
    ('M002AB', 2700.0, 2016, 8000, 'MEDIUM', 1),
    ('M003AB', 1900.0, 2018, 10000, 'MAXIMUM', 1),
    ('M004AB', 3200.0, 2019, 2000, 'PREMIUM', 1),
    ('M005AB', 3000.0, 2017, 5000, 'SPORT', 1),
    -- для бренда TOYOTA
    ('T001CD', 1800.0, 2014, 9000, 'BASIC', 2),
    ('T002CD', 2300.0, 2015, 7000, 'MEDIUM', 2),
    ('T003CD', 2500.0, 2018, 11000, 'MAXIMUM', 2),
    ('T004CD', 2900.0, 2020, 4000, 'PREMIUM', 2),
    ('T005CD', 2700.0, 2019, 6000, 'SPORT', 2),
    -- для бренда BMW
    ('B001EF', 3100.0, 2015, 8000, 'BASIC', 3),
    ('B002EF', 2700.0, 2016, 9000, 'MEDIUM', 3),
    ('B003EF', 2500.0, 2019, 12000, 'MAXIMUM', 3),
    ('B004EF', 3800.0, 2020, 3000, 'PREMIUM', 3),
    ('B005EF', 3500.0, 2018, 7000, 'SPORT', 3),
    -- для бренда FORD
    ('F001GH', 2600.0, 2013, 11000, 'BASIC', 4),
    ('F002GH', 2800.0, 2015, 9000, 'MEDIUM', 4),
    ('F003GH', 2100.0, 2019, 13000, 'MAXIMUM', 4),
    ('F004GH', 3400.0, 2021, 2500, 'PREMIUM', 4),
    ('F005GH', 3200.0, 2017, 6000, 'SPORT', 4),
    -- для бренда AUDI
    ('A001IJ', 2900.0, 2016, 9000, 'BASIC', 5),
    ('A002IJ', 3200.0, 2018, 7000, 'MEDIUM', 5),
    ('A003IJ', 2400.0, 2020, 11000, 'MAXIMUM', 5),
    ('A004IJ', 3800.0, 2022, 3000, 'PREMIUM', 5),
    ('A005IJ', 3600.0, 2019, 5000, 'SPORT', 5);


Чтобы отфильтровать список менеджеров по person_id и получить список enterprise_id,
вы можете использовать метод filter потока в Java и затем преобразовать отфильтрованные записи в список enterprise_id.
Вот как это можно сделать:

java

import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ManagersService {
    private final ManagerRepository managerRepository;

    public ManagersService(ManagerRepository managerRepository) {
        this.managerRepository = managerRepository;
    }

    public List<Long> getEnterpriseIdsByPersonId(Long personId) {
        List<Managers> managersList = managerRepository.findAll();

        return managersList.stream()
            .filter(manager -> manager.getPersonId().equals(personId))
            .map(Managers::getEnterpriseId)
            .collect(Collectors.toList());
    }
}

В этом примере мы используем метод filter, чтобы оставить только записи с заданным person_id,
затем с помощью метода map извлекаем enterprise_id и собираем их в список с помощью collect.
Теперь у вас есть метод getEnterpriseIdsByPersonId,
который позволяет получить список enterprise_id по заданному person_id.

public List<Vehicle> filterVehiclesByEnterprises(List<EnterpriseDTO> enterprisesDTOList, List<Vehicle> allVehicles) {
    List<Integer> enterpriseIds = enterprisesDTOList.stream()
        .map(EnterpriseDTO::getId)
        .collect(Collectors.toList());

    List<Vehicle> filteredVehicles = allVehicles.stream()
        .filter(vehicle -> enterpriseIds.contains(vehicle.getEnterpriseId()))
        .collect(Collectors.toList());

    return filteredVehicles;
}